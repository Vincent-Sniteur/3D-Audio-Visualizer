<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualiseur Audio 3D Immersif</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: radial-gradient(circle at center, #0a0a1a 0%, #000000 100%);
            color: #e0e0ff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        #visualizer-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        #fps-counter {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            color: #00ffcc;
            padding: 6px 12px;
            border-radius: 5px;
            font-size: 0.9rem;
            font-weight: 600;
            z-index: 10;
        }

        #controls-container {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            z-index: 20;
            max-width: 320px;
            width: 100%;
        }

        #controls-wrapper {
            background: rgba(20, 20, 40, 0.85);
            backdrop-filter: blur(12px);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(100, 100, 255, 0.25);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #shape-menu {
            background: rgba(20, 20, 40, 0.85);
            backdrop-filter: blur(12px);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(100, 100, 255, 0.25);
            max-height: 80vh;
            overflow-y: auto;
        }

        .menu-title {
            font-size: 1.2rem;
            font-weight: 700;
            color: #a0a0ff;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-align: center;
        }

        .shape-btn {
            background: transparent;
            border: 1px solid #6666ff;
            color: #a0a0ff;
            padding: 12px 15px;
            width: 100%;
            text-align: center;
            cursor: pointer;
            border-radius: 8px;
            font-size: 1rem;
            transition: all 0.3s ease;
            margin-bottom: 10px;
        }

        .shape-btn:hover, .shape-btn.active {
            background: linear-gradient(90deg, #6a11cb, #2575fc);
            color: white;
            border-color: transparent;
            box-shadow: 0 0 15px rgba(102, 102, 255, 0.7);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 10px;
        }

        .control-label {
            font-size: 0.95rem;
            color: #a0a0ff;
            display: flex;
            justify-content: space-between;
            font-weight: 500;
        }

        .control-label span {
            color: #00ffcc;
            font-weight: 700;
        }

        input[type="file"] {
            display: none;
        }

        .custom-file-upload {
            background: linear-gradient(90deg, #6a11cb, #2575fc);
            color: white;
            display: inline-block;
            padding: 14px 20px;
            cursor: pointer;
            border-radius: 10px;
            text-align: center;
            font-weight: 700;
            transition: all 0.3s ease;
            border: none;
            box-shadow: 0 4px 20px rgba(102, 102, 255, 0.4);
            letter-spacing: 1px;
            text-transform: uppercase;
            font-size: 0.95rem;
            margin-bottom: 15px;
        }

        .custom-file-upload:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 25px rgba(102, 102, 255, 0.7);
        }

        #audio-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            margin-top: 10px;
        }

        #audio-controls button {
            background: rgba(100, 100, 255, 0.2);
            border: 1px solid #6666ff;
            color: #e0e0ff;
            width: 48px;
            height: 48px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.3rem;
            transition: all 0.2s ease;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #audio-controls button:hover {
            background: rgba(102, 102, 255, 0.4);
            transform: scale(1.1);
        }

        #volume-control {
            flex-grow: 1;
            cursor: pointer;
            height: 8px;
            border-radius: 4px;
            background: rgba(100, 100, 255, 0.2);
            accent-color: #6666ff;
        }

        #time-display {
            font-variant-numeric: tabular-nums;
            text-align: center;
            font-size: 0.95rem;
            color: #a0a0ff;
            padding: 8px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            font-weight: 500;
            letter-spacing: 1px;
            margin-top: 10px;
        }

        #sensitivity-control {
            width: 100%;
            cursor: pointer;
            height: 8px;
            border-radius: 4px;
            background: rgba(100, 100, 255, 0.2);
            accent-color: #6666ff;
        }

        .control-btn {
            background: linear-gradient(90deg, #2575fc, #6a11cb);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .control-btn.active {
            background: linear-gradient(90deg, #ff416c, #ff4b2b);
            box-shadow: 0 0 15px rgba(255, 65, 108, 0.5);
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 102, 255, 0.5);
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .btn-group .control-btn {
            flex: 1;
        }

        .bloom-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            background: radial-gradient(circle at center, rgba(100, 150, 255, 0.15) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s ease;
            mix-blend-mode: screen;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            #controls-container {
                position: static;
                max-width: 100%;
                padding: 20px;
            }
            
            #controls-wrapper, #shape-menu {
                padding: 15px;
            }
            
            .shape-btn {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="fps-counter">FPS: 60</div>
    <div id="visualizer-container"></div>
    <div class="bloom-overlay" id="bloom-overlay"></div>
    
    <div id="controls-container">
        <div id="controls-wrapper">
            <label for="audio-file" class="custom-file-upload">
                CHARGER UN FICHIER AUDIO
            </label>
            <input type="file" id="audio-file" accept="audio/*">
            
            <div class="control-group">
                <div class="control-label">
                    SENSIBILIT√â: <span id="sensitivity-value">1.0</span>
                </div>
                <input type="range" id="sensitivity-control" min="0.1" max="2" step="0.1" value="1.0">
            </div>
            
            <div id="audio-controls">
                <button id="rewind-btn">‚è™</button>
                <button id="play-pause-btn">‚ñ∂Ô∏è</button>
                <button id="forward-btn">‚è©</button>
                <input type="range" id="volume-control" min="0" max="1" step="0.01" value="0.8">
            </div>
            
            <div id="time-display">00:00 / 00:00</div>
            
            <div class="btn-group">
                <button id="bloom-toggle" class="control-btn active">
                    <span class="btn-icon">‚ú®</span> Bloom
                </button>
                <button id="rotation-toggle" class="control-btn active">
                    <span class="btn-icon">üîÑ</span> Rotation
                </button>
            </div>
        </div>
        
        <div id="shape-menu">
            <div class="menu-title">EFFETS VISUELS</div>
            <button class="shape-btn active" data-shape="wire-sphere">Sph√®re D√©form√©e</button>
            <button class="shape-btn" data-shape="wire-cube">Cube √âclat√©</button>
            <button class="shape-btn" data-shape="galaxy-spiral">Galaxie Spirale</button>
            <button class="shape-btn" data-shape="spectral-ring">Anneau Spectral</button>
            <button class="shape-btn" data-shape="energy-vortex">Vortex √ânerg√©tique</button>
            <button class="shape-btn" data-shape="crystal-icosahedron">Cristal Fractal</button>
            <button class="shape-btn" data-shape="nebula-explosion">N√©buleuse Cosmique</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Variables globales
            let scene, camera, renderer, analyser, currentObject, audioContext;
            let frameCount = 0, lastCalledTime = performance.now(), fps = 60;
            let sensitivity = 1.0;
            let currentShape = 'wire-sphere';
            let bassData = 0, midData = 0, trebleData = 0;
            let originalPositions = [];
            let bloomEnabled = true;
            let rotationEnabled = true;
            let originalParticlePositions = [];
            let particleTexture;
            let bloomIntensity = 0;
            
            // √âl√©ments du DOM
            const ui = {
                fileInput: document.getElementById('audio-file'),
                audioPlayer: new Audio(),
                playPauseBtn: document.getElementById('play-pause-btn'),
                rewindBtn: document.getElementById('rewind-btn'),
                forwardBtn: document.getElementById('forward-btn'),
                volumeControl: document.getElementById('volume-control'),
                timeDisplay: document.getElementById('time-display'),
                visualizerContainer: document.getElementById('visualizer-container'),
                fpsCounter: document.getElementById('fps-counter'),
                sensitivityControl: document.getElementById('sensitivity-control'),
                sensitivityValue: document.getElementById('sensitivity-value'),
                shapeButtons: document.querySelectorAll('.shape-btn'),
                bloomToggle: document.getElementById('bloom-toggle'),
                rotationToggle: document.getElementById('rotation-toggle'),
                bloomOverlay: document.getElementById('bloom-overlay')
            };
            
            // Cr√©er une texture pour les particules (cercle flou)
            function createParticleTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                
                const context = canvas.getContext('2d');
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = 100;
                
                // Cr√©er un d√©grad√© radial pour un effet flou
                const gradient = context.createRadialGradient(
                    centerX, centerY, 0,
                    centerX, centerY, radius
                );
                gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                gradient.addColorStop(0.1, 'rgba(255, 255, 255, 0.9)');
                gradient.addColorStop(0.5, 'rgba(200, 200, 255, 0.6)');
                gradient.addColorStop(1, 'rgba(100, 100, 255, 0)');
                
                context.fillStyle = gradient;
                context.beginPath();
                context.arc(centerX, centerY, radius, 0, Math.PI * 2);
                context.fill();
                
                return new THREE.CanvasTexture(canvas);
            }
            
            // Initialisation de Three.js
            function init() {
                // Cr√©er la texture de particule
                particleTexture = createParticleTexture();
                
                // Cr√©ation de la sc√®ne
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x0a0a1a);
                
                // Cr√©ation de la cam√©ra
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.z = 50;
                
                // Cr√©ation du rendu
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true, 
                    alpha: true,
                    powerPreference: "high-performance"
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                ui.visualizerContainer.appendChild(renderer.domElement);
                
                // Cr√©ation des lumi√®res
                createLights();
                
                // Cr√©ation du fond d'√©toiles
                createStarField();
                
                // Cr√©ation de la forme initiale
                createShape(currentShape);
                
                // Gestion du redimensionnement
                window.addEventListener('resize', onWindowResize);
                
                // Configuration des √©v√©nements
                setupEventListeners();
                
                // D√©marrage de l'animation
                animate();
            }
            
            // Cr√©ation des lumi√®res
            function createLights() {
                // Lumi√®re directionnelle principale
                const mainLight = new THREE.DirectionalLight(0xffffff, 1.0);
                mainLight.position.set(5, 5, 5);
                scene.add(mainLight);
                
                // Lumi√®re d'ambiance
                const ambientLight = new THREE.AmbientLight(0x404040);
                scene.add(ambientLight);
                
                // Lumi√®res ponctuelles color√©es
                const pointLight1 = new THREE.PointLight(0x2575fc, 2.0, 100);
                pointLight1.position.set(20, 20, 20);
                scene.add(pointLight1);
                
                const pointLight2 = new THREE.PointLight(0x6a11cb, 2.0, 100);
                pointLight2.position.set(-20, -20, -20);
                scene.add(pointLight2);
            }
            
            // Cr√©ation du fond d'√©toiles
            function createStarField() {
                const starCount = 2000;
                const starGeometry = new THREE.BufferGeometry();
                const starPositions = new Float32Array(starCount * 3);
                const starSizes = new Float32Array(starCount);
                const starColors = new Float32Array(starCount * 3);
                
                for (let i = 0; i < starCount * 3; i += 3) {
                    starPositions[i] = (Math.random() - 0.5) * 2000;
                    starPositions[i + 1] = (Math.random() - 0.5) * 2000;
                    starPositions[i + 2] = (Math.random() - 0.5) * 2000;
                    
                    starSizes[i/3] = Math.random() * 1.5 + 0.5;
                    
                    // Couleurs d'√©toiles al√©atoires (blanc, bleu, jaune)
                    const starType = Math.floor(Math.random() * 3);
                    if (starType === 0) {
                        starColors[i] = 1; starColors[i+1] = 1; starColors[i+2] = 1; // Blanc
                    } else if (starType === 1) {
                        starColors[i] = 0.6; starColors[i+1] = 0.7; starColors[i+2] = 1; // Bleu
                    } else {
                        starColors[i] = 1; starColors[i+1] = 0.9; starColors[i+2] = 0.6; // Jaune
                    }
                }
                
                starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
                starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
                starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
                
                const starMaterial = new THREE.PointsMaterial({
                    size: 1.2,
                    vertexColors: true,
                    transparent: true,
                    opacity: 1,
                    sizeAttenuation: true,
                    map: particleTexture
                });
                
                const starField = new THREE.Points(starGeometry, starMaterial);
                scene.add(starField);
            }
            
            // Cr√©ation de la forme
            function createShape(shapeName) {
                currentShape = shapeName;
                
                // Supprimer l'ancien objet
                if (currentObject) {
                    scene.remove(currentObject);
                    if (currentObject.geometry) currentObject.geometry.dispose();
                    if (currentObject.material) currentObject.material.dispose();
                }
                
                let geometry, material;
                const particleCount = 15000;
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const sizes = new Float32Array(particleCount);
                
                switch(shapeName) {
                    case 'wire-sphere':
                        // Sph√®re avec subdivisions pour plus de d√©tails
                        geometry = new THREE.IcosahedronGeometry(15, 10);
                        material = new THREE.MeshBasicMaterial({
                            wireframe: true,
                            color: 0x4a86e8,
                            transparent: true,
                            opacity: 0.9
                        });
                        currentObject = new THREE.Mesh(geometry, material);
                        break;
                    
                    case 'wire-cube':
                        geometry = new THREE.BoxGeometry(30, 30, 30, 15, 15, 15);
                        material = new THREE.MeshBasicMaterial({
                            wireframe: true,
                            color: 0x6a11cb,
                            transparent: true,
                            opacity: 0.85,
                            wireframeLinewidth: 1
                        });
                        currentObject = new THREE.Mesh(geometry, material);
                        break;
                    
                    case 'galaxy-spiral':
                        for (let i = 0; i < particleCount; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const radius = Math.random() * 50;
                            const height = (Math.random() - 0.5) * 30;
                            
                            // Position en spirale
                            positions[i * 3] = Math.cos(angle) * radius;
                            positions[i * 3 + 1] = height;
                            positions[i * 3 + 2] = Math.sin(angle) * radius;
                            
                            // Couleurs bas√©es sur la position
                            colors[i * 3] = 0.2 + Math.abs(Math.sin(angle)) * 0.8;
                            colors[i * 3 + 1] = 0.3 + Math.abs(Math.cos(radius/20)) * 0.7;
                            colors[i * 3 + 2] = 0.8 + Math.abs(Math.sin(angle + radius/30)) * 0.2;
                            
                            // Taille al√©atoire
                            sizes[i] = Math.random() * 0.8 + 0.2;
                        }
                        geometry = new THREE.BufferGeometry();
                        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                        material = new THREE.PointsMaterial({
                            size: 1.2,
                            vertexColors: true,
                            transparent: true,
                            opacity: 0.9,
                            sizeAttenuation: true,
                            map: particleTexture,
                            blending: THREE.AdditiveBlending,
                            depthTest: false
                        });
                        currentObject = new THREE.Points(geometry, material);
                        
                        // Stocker les positions originales pour animation
                        originalParticlePositions = [...positions];
                        break;
                    
                    case 'spectral-ring':
                        const segments = 256;
                        geometry = new THREE.BufferGeometry();
                        const ringPositions = new Float32Array(segments * 3);
                        const ringColors = new Float32Array(segments * 3);
                        
                        // Cr√©er un anneau de particules
                        for (let i = 0; i < segments; i++) {
                            const angle = (i / segments) * Math.PI * 2;
                            const radius = 30;
                            
                            ringPositions[i * 3] = Math.cos(angle) * radius;
                            ringPositions[i * 3 + 1] = 0;
                            ringPositions[i * 3 + 2] = Math.sin(angle) * radius;
                            
                            // Couleurs (d√©grad√© circulaire)
                            const hue = (i / segments) % 1;
                            ringColors[i * 3] = hue;
                            ringColors[i * 3 + 1] = 1 - hue;
                            ringColors[i * 3 + 2] = 1;
                        }
                        
                        geometry.setAttribute('position', new THREE.BufferAttribute(ringPositions, 3));
                        geometry.setAttribute('color', new THREE.BufferAttribute(ringColors, 3));
                        
                        material = new THREE.PointsMaterial({
                            size: 2.5,
                            vertexColors: true,
                            transparent: true,
                            opacity: 0.9,
                            sizeAttenuation: true,
                            map: particleTexture,
                            blending: THREE.AdditiveBlending
                        });
                        
                        currentObject = new THREE.Points(geometry, material);
                        break;
                    
                    case 'energy-vortex':
                        for (let i = 0; i < particleCount; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const radius = Math.random() * 30;
                            const height = (Math.random() - 0.5) * 80;
                            
                            // Position en spirale avec effet vortex
                            positions[i * 3] = Math.cos(angle + height * 0.05) * radius;
                            positions[i * 3 + 1] = height;
                            positions[i * 3 + 2] = Math.sin(angle + height * 0.05) * radius;
                            
                            // Couleurs bas√©es sur la hauteur
                            const heightRatio = (height + 40) / 80;
                            colors[i * 3] = 0.2 + heightRatio * 0.8;
                            colors[i * 3 + 1] = 0.3 + (1 - heightRatio) * 0.7;
                            colors[i * 3 + 2] = 0.8 + heightRatio * 0.2;
                            
                            // Taille al√©atoire
                            sizes[i] = Math.random() * 0.6 + 0.2;
                        }
                        geometry = new THREE.BufferGeometry();
                        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                        material = new THREE.PointsMaterial({
                            size: 1.0,
                            vertexColors: true,
                            transparent: true,
                            opacity: 0.9,
                            sizeAttenuation: true,
                            map: particleTexture,
                            blending: THREE.AdditiveBlending,
                            depthTest: false
                        });
                        currentObject = new THREE.Points(geometry, material);
                        
                        // Stocker les positions originales pour animation
                        originalParticlePositions = [...positions];
                        break;
                    
                    case 'crystal-icosahedron':
                        geometry = new THREE.IcosahedronGeometry(20, 2);
                        material = new THREE.MeshBasicMaterial({
                            wireframe: true,
                            color: 0x00ffcc,
                            transparent: true,
                            opacity: 0.9,
                            wireframeLinewidth: 1
                        });
                        currentObject = new THREE.Mesh(geometry, material);
                        break;
                    
                    case 'nebula-explosion':
                        for (let i = 0; i < particleCount; i++) {
                            const angle1 = Math.random() * Math.PI * 2;
                            const angle2 = Math.random() * Math.PI;
                            const radius = Math.random() * 40;
                            
                            positions[i * 3] = Math.sin(angle2) * Math.cos(angle1) * radius;
                            positions[i * 3 + 1] = Math.cos(angle2) * radius;
                            positions[i * 3 + 2] = Math.sin(angle2) * Math.sin(angle1) * radius;
                            
                            // Couleurs bas√©es sur la distance au centre
                            const dist = Math.sqrt(
                                positions[i * 3] * positions[i * 3] +
                                positions[i * 3 + 1] * positions[i * 3 + 1] +
                                positions[i * 3 + 2] * positions[i * 3 + 2]
                            ) / 40;
                            
                            colors[i * 3] = 0.5 + Math.sin(angle1) * 0.5;
                            colors[i * 3 + 1] = 0.3 + (1 - dist) * 0.7;
                            colors[i * 3 + 2] = 0.8 + Math.sin(dist * 10) * 0.2;
                            
                            // Taille bas√©e sur la distance
                            sizes[i] = (1 - dist) * 1.5 + 0.5;
                        }
                        geometry = new THREE.BufferGeometry();
                        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                        material = new THREE.PointsMaterial({
                            size: 1.5,
                            vertexColors: true,
                            transparent: true,
                            opacity: 0.9,
                            sizeAttenuation: true,
                            map: particleTexture,
                            blending: THREE.AdditiveBlending,
                            depthTest: false
                        });
                        currentObject = new THREE.Points(geometry, material);
                        
                        // Stocker les positions originales pour animation
                        originalParticlePositions = [...positions];
                        break;
                }
                
                scene.add(currentObject);
                
                // Mettre √† jour les boutons actifs
                ui.shapeButtons.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.shape === shapeName);
                });
                
                // Stocker les positions originales pour les d√©formations
                if (shapeName === 'wire-sphere' || shapeName === 'wire-cube' || shapeName === 'crystal-icosahedron') {
                    originalPositions = [];
                    const positionAttribute = geometry.attributes.position;
                    for (let i = 0; i < positionAttribute.count; i++) {
                        originalPositions.push(
                            new THREE.Vector3().fromBufferAttribute(positionAttribute, i)
                        );
                    }
                }
            }
            
            // Configuration des √©v√©nements
            function setupEventListeners() {
                // S√©lection de fichier audio
                ui.fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        ui.audioPlayer.src = URL.createObjectURL(file);
                        ui.audioPlayer.load();
                        setupAudioContext();
                        
                        // Mise √† jour du texte du bouton
                        const fileName = file.name.length > 20 ? file.name.substring(0, 17) + '...' : file.name;
                        document.querySelector('.custom-file-upload').textContent = fileName;
                    }
                });
                
                // Contr√¥les audio
                ui.playPauseBtn.addEventListener('click', () => {
                    if (ui.audioPlayer.paused) {
                        ui.audioPlayer.play();
                        ui.playPauseBtn.textContent = '‚è∏Ô∏è';
                    } else {
                        ui.audioPlayer.pause();
                        ui.playPauseBtn.textContent = '‚ñ∂Ô∏è';
                    }
                });
                
                ui.rewindBtn.addEventListener('click', () => {
                    ui.audioPlayer.currentTime = Math.max(0, ui.audioPlayer.currentTime - 10);
                });
                
                ui.forwardBtn.addEventListener('click', () => {
                    ui.audioPlayer.currentTime = Math.min(ui.audioPlayer.duration, ui.audioPlayer.currentTime + 10);
                });
                
                ui.volumeControl.addEventListener('input', (e) => {
                    ui.audioPlayer.volume = e.target.value;
                });
                
                // Affichage du temps
                ui.audioPlayer.addEventListener('timeupdate', () => {
                    const formatTime = (time) => {
                        const minutes = Math.floor(time / 60).toString().padStart(2, '0');
                        const seconds = Math.floor(time % 60).toString().padStart(2, '0');
                        return `${minutes}:${seconds}`;
                    };
                    ui.timeDisplay.textContent = `${formatTime(ui.audioPlayer.currentTime)} / ${formatTime(ui.audioPlayer.duration || 0)}`;
                });
                
                // Sensibilit√© audio
                ui.sensitivityControl.addEventListener('input', (e) => {
                    sensitivity = parseFloat(e.target.value);
                    ui.sensitivityValue.textContent = sensitivity.toFixed(1);
                });
                
                // Changement de forme
                ui.shapeButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        createShape(button.dataset.shape);
                    });
                });
                
                // Gestion du bloom
                ui.bloomToggle.addEventListener('click', () => {
                    bloomEnabled = !bloomEnabled;
                    ui.bloomToggle.classList.toggle('active', bloomEnabled);
                    ui.bloomToggle.innerHTML = bloomEnabled ? 
                        '<span class="btn-icon">‚ú®</span> Bloom' : 
                        '<span class="btn-icon">üåë</span> Bloom';
                });
                
                // Gestion de la rotation
                ui.rotationToggle.addEventListener('click', () => {
                    rotationEnabled = !rotationEnabled;
                    ui.rotationToggle.classList.toggle('active', rotationEnabled);
                    ui.rotationToggle.innerHTML = rotationEnabled ? 
                        '<span class="btn-icon">üîÑ</span> Rotation' : 
                        '<span class="btn-icon">‚èπÔ∏è</span> Rotation';
                });
            }
            
            // Configuration de l'audio
            function setupAudioContext() {
                if (audioContext) {
                    audioContext.close();
                }
                
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaElementSource(ui.audioPlayer);
                analyser = audioContext.createAnalyser();
                
                source.connect(analyser);
                analyser.connect(audioContext.destination);
                analyser.fftSize = 512;
            }
            
            // Boucle d'animation
            function animate() {
                requestAnimationFrame(animate);
                
                // Calcul des FPS
                frameCount++;
                const now = performance.now();
                if (now >= lastCalledTime + 1000) {
                    fps = Math.round((frameCount * 1000) / (now - lastCalledTime));
                    ui.fpsCounter.textContent = `FPS: ${fps}`;
                    frameCount = 0;
                    lastCalledTime = now;
                }
                
                // Analyse audio et mise √† jour de la forme
                if (analyser && !ui.audioPlayer.paused) {
                    const dataArray = new Uint8Array(analyser.frequencyBinCount);
                    analyser.getByteFrequencyData(dataArray);
                    
                    // Calcul des intensit√©s par plage de fr√©quences
                    bassData = getAverageInRange(dataArray, 0, 20) / 255;
                    midData = getAverageInRange(dataArray, 21, 100) / 255;
                    trebleData = getAverageInRange(dataArray, 101, 255) / 255;
                    
                    // Mise √† jour de la forme
                    updateShape();
                    
                    // Mise √† jour de l'intensit√© du bloom
                    bloomIntensity = bassData * sensitivity * 0.8;
                }
                
                // Rotation de la forme
                if (currentObject && rotationEnabled) {
                    currentObject.rotation.x += 0.001;
                    currentObject.rotation.y += 0.002;
                }
                
                // Rotation de la cam√©ra pour un effet immersif
                if (rotationEnabled) {
                    camera.position.x = 50 * Math.sin(performance.now() * 0.0001);
                    camera.position.z = 50 * Math.cos(performance.now() * 0.0001);
                    camera.lookAt(scene.position);
                }
                
                // Effet bloom - overlay
                if (bloomEnabled && bloomIntensity > 0.1) {
                    ui.bloomOverlay.style.opacity = bloomIntensity;
                    ui.bloomOverlay.style.background = `radial-gradient(circle at center, rgba(100, 150, 255, ${bloomIntensity * 0.6}) 0%, transparent 70%)`;
                } else {
                    ui.bloomOverlay.style.opacity = 0;
                }
                
                // Rendu
                renderer.render(scene, camera);
            }
            
            // Calcul de la moyenne dans une plage
            function getAverageInRange(dataArray, start, end) {
                let sum = 0;
                const count = Math.min(end, dataArray.length - 1) - start + 1;
                for (let i = start; i <= Math.min(end, dataArray.length - 1); i++) {
                    sum += dataArray[i];
                }
                return sum / count;
            }
            
            // Mise √† jour de la forme en fonction de l'audio
            function updateShape() {
                if (!currentObject) return;
                
                // Mise √† jour sp√©cifique √† chaque forme
                switch(currentShape) {
                    case 'wire-sphere':
                        // Pulsation bas√©e sur les basses
                        const bassPulse = 1 + bassData * sensitivity * 1.5;
                        currentObject.scale.set(bassPulse, bassPulse, bassPulse);
                        
                        // D√©formation bas√©e sur les fr√©quences
                        const positionAttribute = currentObject.geometry.attributes.position;
                        const time = performance.now() * 0.001;
                        
                        for (let i = 0; i < positionAttribute.count; i++) {
                            const originalPos = originalPositions[i];
                            
                            // D√©formation bas√©e sur les m√©diums (ondulations)
                            const midDeform = Math.sin(i * 0.2 + time * 3) * midData * sensitivity * 6;
                            
                            // D√©formation bas√©e sur les aigus (d√©tails fins)
                            const highDeform = Math.sin(i * 0.1 + time * 8) * trebleData * sensitivity * 4;
                            
                            // D√©formation bas√©e sur les basses (pulsations profondes)
                            const bassDeform = Math.sin(i * 0.05 + time * 1.5) * bassData * sensitivity * 8;
                            
                            // Combinaison des d√©formations
                            const displacement = bassDeform + midDeform + highDeform;
                            
                            // Application de la d√©formation
                            const newPos = originalPos.clone().normalize()
                                .multiplyScalar(15 + displacement);
                            
                            positionAttribute.setXYZ(i, newPos.x, newPos.y, newPos.z);
                        }
                        
                        positionAttribute.needsUpdate = true;
                        
                        // Changement de couleur bas√© sur les fr√©quences
                        const hue = (time * 0.1 + trebleData * 0.3) % 1;
                        const saturation = 0.7 + midData * 0.3;
                        const lightness = 0.6 + bassData * 0.3;
                        
                        currentObject.material.color.setHSL(hue, saturation, lightness);
                        break;
                    
                    case 'spectral-ring':
                        const positions = currentObject.geometry.attributes.position.array;
                        const colors = currentObject.geometry.attributes.color.array;
                        const binCount = 256;
                        const dataArray = new Uint8Array(analyser.frequencyBinCount);
                        
                        if (analyser) {
                            analyser.getByteFrequencyData(dataArray);
                            
                            for (let i = 0; i < binCount; i++) {
                                const angle = (i / binCount) * Math.PI * 2;
                                const radius = 30 + dataArray[i] * 0.4 * sensitivity;
                                
                                positions[i * 3] = Math.cos(angle) * radius;
                                positions[i * 3 + 1] = Math.sin(dataArray[i] * 0.01) * 10;
                                positions[i * 3 + 2] = Math.sin(angle) * radius;
                                
                                // Couleurs dynamiques
                                const hue = (i / binCount + performance.now() * 0.0005) % 1;
                                colors[i * 3] = hue;
                                colors[i * 3 + 1] = 1 - hue;
                                colors[i * 3 + 2] = 1;
                            }
                            
                            currentObject.geometry.attributes.position.needsUpdate = true;
                            currentObject.geometry.attributes.color.needsUpdate = true;
                        }
                        break;
                    
                    case 'galaxy-spiral':
                    case 'energy-vortex':
                    case 'nebula-explosion':
                        // Animation bas√©e sur les fr√©quences
                        if (rotationEnabled) {
                            currentObject.rotation.y += bassData * 0.05 * sensitivity;
                            currentObject.rotation.x += midData * 0.03 * sensitivity;
                        }
                        
                        // Animation des particules
                        const particlePositions = currentObject.geometry.attributes.position.array;
                        const particleColors = currentObject.geometry.attributes.color.array;
                        const time3 = performance.now() * 0.001;
                        
                        for (let i = 0; i < particlePositions.length; i += 3) {
                            // Appliquer une pulsation bas√©e sur les basses
                            const pulse = 1 + bassData * sensitivity * 0.2;
                            
                            // Ajouter du mouvement bas√© sur les m√©diums
                            const moveX = Math.sin(time3 * 0.5 + i * 0.0001) * midData * sensitivity * 0.8;
                            const moveY = Math.cos(time3 * 0.7 + i * 0.0002) * midData * sensitivity * 0.8;
                            const moveZ = Math.sin(time3 * 0.9 + i * 0.0003) * midData * sensitivity * 0.8;
                            
                            // Appliquer les transformations
                            particlePositions[i] = (originalParticlePositions[i] + moveX) * pulse;
                            particlePositions[i + 1] = (originalParticlePositions[i + 1] + moveY) * pulse;
                            particlePositions[i + 2] = (originalParticlePositions[i + 2] + moveZ) * pulse;
                        }
                        
                        currentObject.geometry.attributes.position.needsUpdate = true;
                        
                        // Changement de couleur dynamique
                        const time4 = performance.now() * 0.001;
                        const hue2 = (time4 * 0.05 + bassData * 0.3) % 1;
                        
                        for (let i = 0; i < particleColors.length; i += 3) {
                            particleColors[i] = hue2;
                            particleColors[i + 1] = 0.8;
                            particleColors[i + 2] = 0.7;
                        }
                        
                        currentObject.geometry.attributes.color.needsUpdate = true;
                        break;
                    
                    case 'wire-cube':
                    case 'crystal-icosahedron':
                        // Animation bas√©e sur les fr√©quences
                        if (rotationEnabled) {
                            currentObject.rotation.y += bassData * 0.03 * sensitivity;
                            currentObject.rotation.x += midData * 0.02 * sensitivity;
                            currentObject.rotation.z += trebleData * 0.01 * sensitivity;
                        }
                        
                        // Changement d'√©chelle
                        const scale = 1 + bassData * 0.8 * sensitivity;
                        currentObject.scale.set(scale, scale, scale);
                        
                        // Changement de couleur
                        const time5 = performance.now() * 0.001;
                        currentObject.material.color.setHSL(
                            (time5 * 0.1) % 1, 
                            0.7 + midData * 0.3, 
                            0.6 + bassData * 0.3
                        );
                        break;
                }
            }
            
            // Gestion du redimensionnement
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            // Initialisation
            init();
        });
    </script>
</body>
</html>